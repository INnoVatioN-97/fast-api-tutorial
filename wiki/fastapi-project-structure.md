# FastAPI 프로젝트 구조: 모델, 서비스, 라우터 분리

FastAPI 애플리케이션이 커지면서 모든 로직을 하나의 파일에 두는 것은 유지보수를 어렵게 만듭니다. 코드를 기능과 역할에 따라 여러 파일로 분리하는 것은 좋은 설계의 첫걸음입니다. "관심사의 분리(Separation of Concerns)" 원칙을 따르는 일반적인 구조는 다음과 같습니다.

---

## 1. 역할 분담

### 📄 `models.py`
*   **역할:** 데이터의 모양(Shape)을 정의합니다.
*   **내용:** Pydantic의 `BaseModel`을 상속받는 클래스들을 이곳에 모아둡니다. 이 모델들은 API의 요청 본문(Request Body), 응답(Response), 그리고 서비스 레이어와 데이터베이스 레이어 간의 데이터 교환에 사용됩니다.
*   **예시:** `User`, `Product`, `Campaign` 등.

### ⚙️ `services.py`
*   **역할:** 실제 비즈니스 로직을 처리합니다. "애플리케이션이 실제로 무엇을 하는가"에 대한 코드가 담깁니다.
*   **내용:** 외부 API 호출, 데이터베이스와의 상호작용, 복잡한 계산 등 핵심 로직을 함수나 클래스로 구현합니다. 이 레이어는 HTTP 요청이나 라우팅에 대해 전혀 알지 못해야 합니다.
*   **예시:** `create_user_in_db()`, `send_campaign_to_external_api()`, `calculate_order_total()`.

### 🔌 `routers/{feature}.py`
*   **역할:** HTTP 요청을 받고, 적절한 서비스 함수를 호출한 뒤, 그 결과를 클라이언트에게 반환합니다.
*   **내용:** FastAPI의 `APIRouter`를 사용하여 엔드포인트(`@router.post("/users")` 등)를 정의합니다. 요청 본문의 유효성 검사(Pydantic 모델을 통해), 경로 파라미터 처리 등을 담당합니다. 비즈니스 로직은 직접 수행하지 않고 서비스 레이어에 위임합니다.

### 🚀 `main.py`
*   **역할:** 애플리케이션의 시작점(Entrypoint)입니다.
*   **내용:** FastAPI 앱 인스턴스를 생성하고, `routers`에 정의된 모든 `APIRouter`들을 앱에 포함(`app.include_router()`)시키는 역할을 합니다. 전역 미들웨어나 CORS 설정 등도 이곳에서 할 수 있습니다.

## 2. 데이터 흐름

클라이언트의 요청은 다음과 같은 순서로 처리됩니다.

`Client` -> `main.py` -> `Router` -> `Service` -> `(External API / DB)` -> `Service` -> `Router` -> `Client`

## 3. 왜 이렇게 분리할까요?

*   **유지보수성:** 코드가 역할별로 정리되어 있어 특정 기능을 찾거나 수정하기 쉽습니다.
*   **테스트 용이성:** 서비스 레이어는 HTTP 요청과 독립적이므로, 비즈니스 로직만 따로 떼어내어 단위 테스트를 작성하기 매우 편리합니다.
*   **재사용성:** 하나의 서비스 함수를 여러 다른 라우터나 다른 서비스에서 재사용할 수 있습니다.
*   **팀 협업:** 여러 개발자가 각자 다른 파일(라우터, 서비스 등)을 동시에 작업하기 용이합니다.
